START


LET A SIGNED
LET AA							
LET B BE 1
LET C AS 2
LET D AS 2 BE 2
LET E
PASSTHROC printf("*********ASSIGNMENT*********\n");
PASSTHROC printf("%d\n", A[0].data);
PASSTHROC printf("%d\n", AA[0].data);
PASSTHROC printf("%d\n", B[0].data);
PASSTHROC printf("%d\n", C[0].data);
PASSTHROC printf("%d\n", D[0].data);
PASSTHROC printf("%d\n\n\n", E[0].data);

A BE B
AA BE 3

PASSTHROC printf("%d\n", A[0].data);
PASSTHROC printf("%d\n\n\n", AA[0].data);


PASSTHROC printf("*********UNARY/BINARY*********\n");
A BE NEGATE A
B BE INCREMENT B
AA BE DECREMENT AA

PASSTHROC printf("%d\n", A[0].data);
PASSTHROC printf("%d\n", B[0].data);
PASSTHROC printf("%d\n\n\n", AA[0].data);

A BE B ADD AA
B BE A SUBTRACT 1
C BE 5 MODULUS 3
D BE 2 MULTIPLY 3
E BE 7 DIVIDE 2

PASSTHROC printf("%d\n", A[0].data);
PASSTHROC printf("%d\n", B[0].data);
PASSTHROC printf("%d\n", C[0].data);
PASSTHROC printf("%d\n", D[0].data);
PASSTHROC printf("%d\n\n\n", E[0].data);

LET ZZ 
LET Z BE 1
Z BE NOT Z

PASSTHROC printf("%d\n\n\n", Z[0].data);

Z BE 0
Z BE NOT Z

PASSTHROC printf("%d\n\n\n", Z[0].data);

LET Y BE 0
LET X BE 0
Z BE Y ALSO X
ZZ BE Y EITHER X
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n\n\n", ZZ[0].data);

Y BE 0
X BE 1
Z BE Y ALSO X
ZZ BE Y EITHER X
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n\n\n", ZZ[0].data);

Y BE 1
X BE 0
Z BE Y ALSO X
ZZ BE Y EITHER X
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n\n\n", ZZ[0].data);

Y BE 1
X BE 1
Z BE Y ALSO X
ZZ BE Y EITHER X
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n\n\n", ZZ[0].data);

Y BE COMPLEMENT Y
PASSTHROC printf("%d\n\n\n", Y[0].data);


PASSTHROC printf("*********BINARY BITWISE*********\n");
LET ZZZ
LET ZZZZ
LET ZZZZZ
LET ZZZZZZ

X BE 0
Y BE 0
Z BE X AND Y
ZZ BE X OR Y
ZZZ BE X XOR Y
ZZZZ BE X NAND Y
ZZZZZ BE X NOR Y
ZZZZZZ BE X XNOR Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 0
Y BE 1
Z BE X AND Y
ZZ BE X OR Y
ZZZ BE X XOR Y
ZZZZ BE X NAND Y
ZZZZZ BE X NOR Y
ZZZZZZ BE X XNOR Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 1
Y BE 0
Z BE X AND Y
ZZ BE X OR Y
ZZZ BE X XOR Y
ZZZZ BE X NAND Y
ZZZZZ BE X NOR Y
ZZZZZZ BE X XNOR Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 1
Y BE 1
Z BE X AND Y
ZZ BE X OR Y
ZZZ BE X XOR Y
ZZZZ BE X NAND Y
ZZZZZ BE X NOR Y
ZZZZZZ BE X XNOR Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 10
Y BE 3
Z BE X AND Y
ZZ BE X OR Y
ZZZ BE X XOR Y
ZZZZ BE X NAND Y
ZZZZZ BE X NOR Y
ZZZZZZ BE X XNOR Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);


PASSTHROC printf("*********COMPARITORS*********\n");
X BE 0
Y BE 0
Z BE X EQUALS Y
ZZ BE X NOTEQUALS Y
ZZZ BE X GREATER Y
ZZZZ BE X GREATEREQUALS Y
ZZZZZ BE X LESS Y
ZZZZZZ BE X LESSEQUALS Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 0
Y BE 1
Z BE X EQUALS Y
ZZ BE X NOTEQUALS Y
ZZZ BE X GREATER Y
ZZZZ BE X GREATEREQUALS Y
ZZZZZ BE X LESS Y
ZZZZZZ BE X LESSEQUALS Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);

X BE 1
Y BE 0
Z BE X EQUALS Y
ZZ BE X NOTEQUALS Y
ZZZ BE X GREATER Y
ZZZZ BE X GREATEREQUALS Y
ZZZZZ BE X LESS Y
ZZZZZZ BE X LESSEQUALS Y
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n", ZZ[0].data);
PASSTHROC printf("%d\n", ZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZ[0].data);
PASSTHROC printf("%d\n", ZZZZZ[0].data);
PASSTHROC printf("%d\n\n\n", ZZZZZZ[0].data);


PASSTHROC printf("*********CONDITIONALS*********\n");
Z BE 1
ZZ BE 0
IF Z
PASSTHROC printf("1 IF\n");
ELSEIF ZZ
PASSTHROC printf("1 ELSEIF\n");
ELSE
PASSTHROC printf("1 ELSE\n");
ENDIF

Z BE 0
ZZ BE 1
IF Z
PASSTHROC printf("2 IF\n");
ELSEIF ZZ
PASSTHROC printf("2 ELSEIF\n");
ELSE
PASSTHROC printf("2 ELSE\n");
ENDIF

Z BE 0
ZZ BE 0
IF Z
PASSTHROC printf("3 IF\n");
ELSEIF ZZ
PASSTHROC printf("3 ELSEIF\n");
ELSE
PASSTHROC printf("3 ELSE\n\n\n");
ENDIF

Z BE 3
LOOPWHILE Z
PASSTHROC printf("%d\n", Z[0].data);
Z BE DECREMENT Z
ENDLOOP

PASSTHROC printf("\n\n");

Z BE 3
Y BE 3
LOOPWHILE Z
PASSTHROC printf("%d\n", Z[0].data);
PASSTHROC printf("%d\n\n", Y[0].data);
ZZ BE Y DIVIDE 3
IF ZZ
Z BE DECREMENT Z
Y BE DECREMENT Y
LOOPAGAIN
ENDIF
Z BE DECREMENT Z
ENDLOOP

PASSTHROC printf("\n");

Z BE 3
LOOPWHILE Z
PASSTHROC printf("%d\n\n\n", Z[0].data);
EXITLOOP
ENDLOOP

Z BE 1
IF Z
PASSTHROC printf("%d\n\n\n", Z[0].data);
EXITIF
PASSTHROC printf("PASSTHROC FAILED\n\n\n");
ENDIF

PASSTHROC printf("********GOTO/LABELS*********\n");
Z BE 1
LABEL LAB
PASSTHROC printf("LAB\n");
IF Z
Z BE DECREMENT Z
PASSTHROC printf("GOTO LAB\n");

GOTO LAB
ENDIF

PASSTHROC printf("*********FUNCTIONS*********\n");
PASSTHROC printf("B4 FUNC1\n");
CALL F1
PASSTHROC printf("AFTER FUNC1\n\n\n");

PASSTHROC printf("B4 NESTED FUNC\n");
CALL F2
PASSTHROC printf("AFTER NESTED FUNC\n\n\n");

Z BE 3
CALL FTAKES Z
PASSTHROC printf("%d should be 3\n\n\n", Z[0].data);

ZZ BE 1
CALL FTAKES2 Z ASWELL ZZ ASWELL ZZZ
PASSTHROC printf("%d should be 1\n\n\n", ZZ[0].data);

CALL R RETURNS Z
PASSTHROC printf("%d should be 5\n\n\n", Z[0].data);

Z BE 2
ZZ BE 1
CALL R2 RETURNS Z TAKES Z ASWELL ZZ
PASSTHROC printf("%d should be 1\n", ZZ[0].data);
PASSTHROC printf("%d should be 2\n\n\n", Z[0].data);




PASSTHROC printf("*********TEST I/O*********\n");
/#Commenting ut this section for now 
CALL TESTREADWRITE

CALL TESTERBEEP
#/

PASSTHROC printf("*********FILES*********\n");
LET F AS 2
FILESIZE F FILETEST
PASSTHROC printf("%d\n", F[0].data);
PASSTHROC printf("%d\n\n\n", F[1].data);

PASSTHROC printf("*********GETC/PUTC AT TEST*********\n");
#CALL GETAT
#CALL VARAT
CALL FILEIO

PASSTHROC printf("*********DAFUQ*********\n");
/#This doesnt seem right to me...
Shouldnt it being as 1 mean i can only assign 1 thing to it?
#/

LET P AS 1

PASSTHROC printf("%d\n", P[0].data);
PASSTHROC printf("%d\n\n\n", P[1].data);
PASSTHROC printf("%d\n", P[3].data);
PASSTHROC P[4].data = 12;
PASSTHROC printf("%d\n\n\n", P[4].data);
PASSTHROC P[8].data = 12;
PASSTHROC printf("%d\n\n\n", P[8].data);


PASSTHROC printf("B4 EARLYEND\n");
EARLYEND
PASSTHROC printf("EARLYEND FAILED\n");


END


###################		FUNCTIONS    	####################################################

FUNCTION F1
	PASSTHROC printf("IN FUNC1\n");
ENDFUNCTION

FUNCTION F2
	PASSTHROC printf("IN FUNC2\n");
	CALL F3
ENDFUNCTION

FUNCTION F3
	PASSTHROC printf("IN FUNC3\n");
ENDFUNCTION

FUNCTION FTAKES TAKES Z 
	PASSTHROC printf("%d\n", Z[0].data);
	Z BE 1
	PASSTHROC printf("%d\n", Z[0].data);
ENDFUNCTION

FUNCTION FTAKES2 TAKES Z ASWELL ZZ ASWELL ZZZ
	PASSTHROC printf("%d\n", ZZ[0].data);
	ZZ BE 2
ENDFUNCTION

FUNCTION R RETURNS Z
	LET G BE 5
	PASSTHROC printf("%d\n", G[0].data);
	RETURN G
ENDFUNCTION

FUNCTION R2 RETURNS Z TAKES Z ASWELL ZZ
	ZZ BE 9
	PASSTHROC printf("%d\n", ZZ[0].data);
	RETURN Z
ENDFUNCTION

FUNCTION TESTERBEEP
	LET OUT AS 2 SIGNED
	LET IN AS 2 SIGNED
	LET NEW AS 10 SIGNED
	
	#PASSTHROC puts("derp");
	CALL GETCHAR OUT
	CALL PUTCHAR OUT FILETEST
	
	CALL GETCHAR IN FILETEST.1 FOR 7
	CALL PUTCHAR IN
	
	#Print first 5 chars to FILETEST.2
	CALL PUTCHAR IN FILETEST.2 FOR 5
	
	PASSTHROC printf("\n");
	CALL GETCHAR NEW FOR 5
	CALL PUTCHAR NEW FOR 5
	PASSTHROC printf("\n");
	
	PASSTHROC int cntr = 0;
	PASSTHROC while(cntr < 10){
	PASSTHROC printf("\n%d\n", NEW[cntr].data);
	PASSTHROC printf("%d\n", NEW[cntr+1].data);
	PASSTHROC cntr = cntr + 2;
	PASSTHROC }
ENDFUNCTION

FUNCTION TESTREADWRITE
	LET TEST AS 40
	
	#Causes error if >=13
	#CALL GETCHAR is the line that kills it 
	#Changed size of test to 40 and now it seems to be working
	#I may just be dumb and tried to add to many values for the size of 20...
	CALL GETCHAR TEST FILETEST FOR 18
	CALL PUTCHAR TEST FOR 18
	PASSTHROC printf("\n");
ENDFUNCTION


FUNCTION GETAT
	LET ATTEST AS 10
	CALL GETCHAR ATTEST FILETEST AT 1 FOR 5
	CALL PUTCHAR ATTEST FOR 5
	PASSTHROC printf("\n");
	
	LET REC AS 10
	CALL GETCHAR REC FILETEST FOR 5
	CALL PUTCHAR REC FILETEST.3 AT 2 FOR 5
ENDFUNCTION

FUNCTION VARAT
	LET VAR AS 6
	CALL GETCHAR VAR AT 2 
	CALL PUTCHAR VAR AT 2

	PASSTHROC printf("\n");
	
	PASSTHROC int cntr = 0;
	PASSTHROC while(cntr < 6){
	PASSTHROC printf("\n%d\n", VAR[cntr].data);
	PASSTHROC printf("%d\n", VAR[cntr+1].data);
	PASSTHROC cntr = cntr + 2;
	PASSTHROC }	
ENDFUNCTION

#test all of the file io options available
FUNCTION FILEIO
	LET IO AS 10
	LET IO2 AS 10
	LET SZ AS 2
	
	FILESIZE SZ FILETEST
	
	CALL GETCHAR IO FILETEST
	CALL PUTCHAR IO
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO[0].data);
	PASSTHROC printf("%d\n", IO[1].data);
	PASSTHROC printf("\n");
	
	CALL GETCHAR IO AT 2 FILETEST
	CALL PUTCHAR IO AT 2
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO[2].data);
	PASSTHROC printf("%d\n", IO[3].data);
	PASSTHROC printf("\n");
	
	CALL PUTCHAR IO NEWFILE
	CALL GETCHAR IO2 NEWFILE
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO2[0].data);
	PASSTHROC printf("%d\n", IO2[1].data);
	PASSTHROC printf("\n");
	
	CALL GETCHAR IO FILETEST FOR 3
	CALL PUTCHAR IO FOR 3
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO[0].data);
	PASSTHROC printf("%d\n", IO[1].data);
	PASSTHROC printf("%d\n", IO[2].data);
	PASSTHROC printf("%d\n", IO[3].data);
	PASSTHROC printf("%d\n", IO[4].data);
	PASSTHROC printf("%d\n", IO[5].data);
	PASSTHROC printf("\n");
	
	CALL PUTCHAR IO AT 2 NEWFILE
	CALL GETCHAR IO2 AT 2 NEWFILE
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO2[2].data);
	PASSTHROC printf("%d\n", IO2[3].data);
	PASSTHROC printf("\n");
	
	CALL PUTCHAR IO NEWFILE AT 2
	CALL GETCHAR IO NEWFILE AT 2
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO[0].data);
	PASSTHROC printf("%d\n", IO[1].data);
	PASSTHROC printf("\n");
	
	CALL PUTCHAR IO AT 2 NEWFILE AT 2 FOR 2
	CALL GETCHAR IO2 AT 3 FILETEST AT 3 FOR 3
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO2[6].data);
	PASSTHROC printf("%d\n", IO2[7].data);
	PASSTHROC printf("%d\n", IO2[8].data);
	PASSTHROC printf("%d\n", IO2[9].data);
	PASSTHROC printf("%d\n", IO2[10].data);
	PASSTHROC printf("%d\n", IO2[11].data);
	PASSTHROC printf("\n");
	
	CALL GETCHAR IO2 FILETEST AT 3 FOR 3
	PASSTHROC printf("\n");
	PASSTHROC printf("%d\n", IO2[0].data);
	PASSTHROC printf("%d\n", IO2[1].data);
	PASSTHROC printf("%d\n", IO2[2].data);
	PASSTHROC printf("%d\n", IO2[3].data);
	PASSTHROC printf("%d\n", IO2[4].data);
	PASSTHROC printf("%d\n", IO2[5].data);
	PASSTHROC printf("\n");

ENDFUNCTION
